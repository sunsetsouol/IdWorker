# README

分布式id生成器，通过策略工厂等设计模式整合多种id生成策略

## UUID

UUID是一个128位的通用唯一识别码，重复概率极低，按照维基百科的说法，“每秒产生10亿个UUID且持续约100年，产生一个重复UUID的概率才达到50%”

该方法生成id的优点是：

1. 生成id简单，服务器不需要任何协调，所以不会有任何同步问题
2. 系统易扩展，每个服务器值负责生成他们自己使用的ID，ID服务器可以很容易的随服务器一起扩展

缺点：

1. ID是128位的比较长
2. 生成的ID类型不是数字而是字符串
3. ID不随时间增加，插入效率低



## TicketServers

工单服务器，这个方法主要是利用了单数据库服务器的自增特性，更多的原理请参考 [Flicker的文章 ”Ticket Servers: Distributed Unique Primary Keys on the Cheap“](https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/)

该方法的优点是容易实现，适合中小型应用

缺点也很明显，存在单点故障问题，为了避免这个问题，我们可以设置多个工单服务器，但是这就会引入新的数据同步问题，这里不做详细论述



## SnowFlake

这里使用了推特的雪花算法生成唯一ID，这是一个64位的ID，由以下几个部分组成

1. 符号位（1位）：符号位始终为0保证ID是正数
2. 时间戳（41位）：从纪元或自定义纪元开始以来的毫秒数
3. 数据中心ID（5位）：分布式状态下给每个数据中心一个唯一的ID，最多可以有32(2^5)个数据中心
4. 机器ID（5位）：分布式下给每个数据中心的服务器一个唯一的ID，最多可以有32(2^5)个机器
5. 序列号（12位）：对于一个进程，每生成一个ID序列号就加一，每毫秒开始序列号重置为0

数据中心和机器ID在系统运行起来的时候就是固定的了，注意要保证二者的唯一

时间戳可以随时间不断增长，保证ID可以按时间排序，41位的时间戳毫秒大约可以使用69年，只要将纪元时间定制的足够近就可以延迟溢出时间

序列号有12位，相当于4096种组合，理论上一台机器一毫秒最多可以生成4096个id

对于低并发且长时间运行的应用，减少序列号的长度，增加时间戳的长度，可以维持ID生成器运行更长的时间